{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Presentaci\u00f3n","text":"<p>Mi nombre es Juan Manuel Gaona Serrano </p>"},{"location":"#descripcion","title":"Descripci\u00f3n","text":"<p>Actualmente me encuentro en mi primer semestre de ingenieria mecatronica en la universidad ibero Puebla.</p>"},{"location":"#habilidades","title":"Habilidades","text":"<p>Entre mis habilidades se encuentra el dise\u00f1o en 3D y uno de mis grandes hobbies es el basquetbol.</p>"},{"location":"#contacto","title":"Contacto","text":"<p>Puedes contactarme a trav\u00e9s del correo 204137@iberopuebla.mx o el n\u00famero 2229218870</p>"},{"location":"#logros","title":"Logros","text":"<p>Entre las cosas de las que me siento orgulloso es la obtenci\u00f3n de la beca de buscamos tu talento ganando el segundo lugar para mi carrera.</p>"},{"location":"Bit%C3%A1cora%20de%20Proyectos/","title":"Bit\u00e1cora de Proyectos - Juan Manuel Gaona Serrano","text":"<p>Este es el espacio donde documento y rastreo el progreso de mis diferentes proyectos como estudiante.</p>"},{"location":"Bit%C3%A1cora%20de%20Proyectos/#informacion-personal","title":"Informaci\u00f3n Personal","text":"<p>Nombre Completo: Juan Manuel Gaona Serrano</p> <p>Ocupaci\u00f3n: Estudiante de Ingenier\u00eda Mecatr\u00f3nica en la Universidad Iberoamericana (IBERO)</p> <p>Intereses: Rob\u00f3tica, electronica, automatizaci\u00f3n, programaci\u00f3n, dise\u00f1o e impresi\u00f3n 3d.</p>"},{"location":"Bit%C3%A1cora%20de%20Proyectos/#proyectos-en-curso","title":"Proyectos en Curso","text":"<p>A continuaci\u00f3n, se presentan los tres proyectos principales en los que estoy trabajando o he completado. Haz clic en el t\u00edtulo de cada proyecto para ver su repositorio dedicado.</p> <ol> <li>Conexi\u00f3n de ESP32</li> </ol> <p>Proyecto 1</p> <ol> <li>Uso de motores y servomotres</li> </ol> <p>[Proyecto 2](</p> <ol> <li>Carro con llantas omnidireccionales</li> </ol> <p>[Proyecto 3](</p>"},{"location":"Bit%C3%A1cora%20de%20Proyectos/#contacto","title":"Contacto","text":"<p>Puedes contactarme a trav\u00e9s de mi Correo Electr\u00f3nico o por mi n\u00famero de celular.</p> <p>Correo electronico: juangaona712@gmail.com</p> <p>N\u00famero de celular: 2229218870</p>"},{"location":"Proyecto%201/","title":"\ud83d\udcda Proyecto 1","text":""},{"location":"Proyecto%201/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Conexi\u00f3n de ESP32 </li> <li>Equipo / Autor(es): Juan Manuel Gaona Serrano </li> <li>Curso / Asignatura: Introducci\u00f3n a la mecatronica </li> <li>Fecha: 13/09/2025 </li> <li>Descripci\u00f3n breve: En este proyecto utilizamos un ESP32 para cargarle diferentes codigos y prender un led de diferentes formas, todo con el fin de aprender a utilizar la placa.</li> </ul>"},{"location":"Proyecto%201/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Conectar la placa con un celular usando una se\u00f1al de bluetooth.</li> <li>Espec\u00edficos:</li> <li>Codigo de conexi\u00f3n bluetooth</li> <li>Uso de la placa ESP32</li> <li>Cargar codigo a placa</li> </ul>"},{"location":"Proyecto%201/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Codigo para conectar la placa al celular.</li> <li>No incluye: La conexi\u00f3n del led en la protoboard.</li> </ul>"},{"location":"Proyecto%201/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Phyton - Serial Bluetooth Terminal.</p> <p>Hardware (si aplica) - ESP32 - Foco led - Protoboard - Resistencia de 220</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica - Electr\u00f3nica b\u00e1sica</p>"},{"location":"Proyecto%201/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<p><pre><code>ich_sep12a ino\nconst int led - 13;\nconst int btn = 12;\nvoid setup() {\n//inicio la concat\nSerial.begin(115200);\npinMode(led, OUTPUT);\npinMode(btn, INPUT);\nvoid loop() {\nint estado digitalRead(btn);\nif (estado 1) (\ndigitalWrite(led, 1);\nSerial.println(\"ON\");\n} else {\ndigitalWrite(led, 0);\nSerial.println(\"OFF\");\n</code></pre> Se cargo este c\u00f3digo a la placa ESP32 donde colocamos un bot\u00f3n para prender el led usando un bot\u00f3n.</p> <p>Video Uso del programa</p> <p><pre><code>const int LED = 13;\n#include \"BluetoothSerial.h\"\nBluetoothSerial SerialBT;\n\nvoid setup() {\n}\n\npinMode (13,OUTPUT);\nSerial.begin(115200);\nSerialBT.begin(\"ESP32juans\"); // Nombre del dispositivo Bluetooth\n\nvoid loop() {\nif (SerialBT.available()) {\nString mensaje SerialBT.readString();\nSerial.println(\"Recibido:\" + mensaje);\nif (mensaje == \"1\") {\n}\n\ndigitalWrite(LED, HIGH);\n\nelse {\ndigitalWrite(LED, LOW);\ndelay(1000);\n}\n</code></pre> Este c\u00f3digo fue el que se us\u00f3 para conectar la placa con el celular usando bluetooth, una vez cargado el c\u00f3digo se instal\u00f3 la aplicaci\u00f3n Serial Bluetooth Terminal en un dispositivo android y simplemente se hicieron las conexiones de acuerdo a los pines, se vincul\u00f3 el dispositivo con el nombre que se le dio en el c\u00f3digo en el caso juans y se mand\u00f3 un 1 o un 0 para prender o apagar el led.</p> <p>Video Uso del programa</p>"},{"location":"Proyecto%202/","title":"\ud83d\udcda Proyecto 2","text":""},{"location":"Proyecto%202/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Uso de motores y servomotres </li> <li>Equipo / Autor(es): Juan Manuel Gaona Serrano </li> <li>Curso / Asignatura: Introducci\u00f3n a la mecatronica </li> <li>Fecha: 26/09/2025 </li> <li>Descripci\u00f3n breve: En este proyecto utilizamos motores y servomotores para poder controlarlos.</li> </ul>"},{"location":"Proyecto%202/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Aprender a usar los motores y servomoters.</li> <li>Espec\u00edficos:</li> <li>Conexiones de motores y servomotores</li> <li>Uso de la placa ESP32</li> <li>Cargar codigo a placa</li> </ul>"},{"location":"Proyecto%202/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Codigo y conexi\u00f3n para utilizar los motores y servomotores.</li> <li>No incluye: El uso de fuente de poder.</li> </ul>"},{"location":"Proyecto%202/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Phyton</p> <p>Hardware (si aplica) - ESP32 - motor pololu - servomotor</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica - Electr\u00f3nica b\u00e1sica</p>"},{"location":"Proyecto%202/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<p><pre><code>#define in1 18\n\n#define in1 19\n\nvoid setup() {\n\n// put your setup code here, to run once:\n\npinMode(in1, OUTPUT);\n\npinMode(in2, OUTPUT);\n\n}\n\nvoid loop() {\n\n/*\n\n1.-Motor avance en una direccion durante 4 segs\n\n2.-Pare 2segs\n\n3.-Motor avanza en direccion opuesta\n\n*/\n\n//Avance cw\n\ndigitalWrite(in1, 1);\n\ndigitalWrite(in2, 0);\n\ndelay(4000);\n\ndigitalWrite(in1, 0);\n\ndigitalWrite(in2, 0);\n\ndelay(2000);\n\ndigitalWrite(in1, 0);\n\ndigitalWrite(in2, 1);\n\ndelay(4000);\n\n\n}\n</code></pre> Con este c\u00f3digo se logra mover un motor a un lado durante 4 segundos y despu\u00e9s se mueve al otro lado durante otros 4 segundos.</p> <p>Video Uso del programa</p> <p><pre><code>#define in1 18\n\n#define in2 19\n\n#define pum 21\n\nvoid setup() (\n\n// put your setup code here, to run once\n\npinMode(in1, OUTPUT);\n\npinMode(in2, OUTPUT);\n\nledcAttach(pum, 1000,8);\n\nvoid loop() {\n\n// put your main code here, to run repeatedly:\n\nfor(int i=0; 1 &lt;= 255; 1++){\n\n}\n\nledcwrite(pwm,1);;\n\ndigitalwrite(in1,1);\n\ndigitalWrite(in2,0);\n\ndeley(400);\n\ndigitalWrite(in1,0);\n\ndigitalwrite(in1,0);\n\ndelay(200);\n\ndigitalwrite(in1,0);\n\ndigitalWrite(in1,1);\n\ndelay\u00a0(400)\n}\n</code></pre> Con este c\u00f3digo se logra acelerar y desacelerar de un lado a otro usando un motor.</p> <p>Video Uso del programa</p> <p><pre><code> ep26d.ino\n\nESP32 Wrover Module\n\n/Control de 1 solo motor/\n\n#define pwm 12 //Definicion de pin de Velocidad\n\nint duty = 0;\n\nint grados = theta\n\nint aumento = 0;\n\nvoid setup() {\n\n}\n\n/Declarar Pines Como salida/\n\n/*Configuracion de pin PWM\n\nSe conecta al pin 12(pwm)\n\n- Frecuencia de 50hz\n\nResolucion de 12 bit (0-4096)\n\nCanal 8\n\nledcAttachChannel (pwm, 50, 12, 0);\n\nSerial.begin(115200);\n\nvoid loop() {\n\n/*\n\nServo trabaja del 5% al ~10% del total\n\n(- 5)% - 0 deg\n\n(- 16)% - 180 deg\n\n5% de 4096 = 204.8\n\n10% de 4 theta96=4 theta9.6\n\nfor(int i = 0 i &lt;= 180 ; i +=10) {\n\naumento\u00a0=\u00a0i;\n\ngrados=0;\n\nduty map(grados, 0, 180, 205, 410);\n\nSerial.print(\"Pos: \");\n\nSerial.println(duty);\n\nledcWrite(pwm, duty);\n\ndelay(500);\n\nduty map(aumento, 0, 180, 205, 410);\n\nSerial.print(\"Pos: \");\n\nSerial.println(duty);\n\nSerial.println(aumento);\n\nledcWrite(pwm, duty);\n\ndelay(500);\n\n}\n\n}\n</code></pre> Este c\u00f3digo fue utilizado para controlar un servomotor, su funci\u00f3n es avanzar 10 grados y regresar a 0, avanzar otros 10 y regresar a 0 y as\u00ed sucesivamente.</p> <p>Video Uso del programa</p>"},{"location":"Proyecto%203/","title":"\ud83d\udcda Proyecto 1","text":""},{"location":"Proyecto%203/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Carro con llantas omnidireccionales </li> <li>Equipo / Autor(es): Juan Manuel Gaona Serrano </li> <li>Curso / Asignatura: Introducci\u00f3n a la mecatronica </li> <li>Fecha: 17/10/2025 </li> <li>Descripci\u00f3n breve: En este proyecto realizamos un carro control remoto con contorl de xbox y ruedas omnidireccionales.</li> </ul>"},{"location":"Proyecto%203/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Crear un carro para competir en un torneo de futbol.</li> <li>Espec\u00edficos:</li> <li>C\u00f3digo de conexi\u00f3n a xbox</li> <li>Dise\u00f1o en 3D</li> <li>C\u00f3digo de llantas omnidereccionales</li> </ul>"},{"location":"Proyecto%203/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Codigo para conectar el control de xbox a ESP32. Modelo 3d de las partes del carro. Codigo de movimiento llantas omniderrcionales.</li> <li>No incluye: La conexi\u00f3n del carro.</li> </ul>"},{"location":"Proyecto%203/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Solidwords - C++</p> <p>Hardware (si aplica) - ESP32 - Control de xbox - Protoboard - Resistencias, cables - 4 pilas recargables tipo C - 4 llantas omniderccionales - 4 motores DC 3</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica - Electr\u00f3nica b\u00e1sica - Dise\u00f1o en 3d basico</p>"},{"location":"Proyecto%203/#5-instalacion","title":"5) Instalaci\u00f3n","text":""},{"location":"Proyecto%203/#codigo-para-conectar-la-placa-esp32-a-el-control-de-xbox-para-mover-los-cuatro-motores","title":"Codigo para conectar la placa ESP32 a el control de xbox para mover los cuatro motores","text":"<pre><code>// ====== Control 4xM con Xbox (Bluepad32 + ESP32) ======\n#include &lt;Bluepad32.h&gt;\n\n// ================== Pines actualizados ==================\n// Trasero Izquierdo (RL)\n#define MI1 12\n#define MI2 14\n// Trasero Derecho (RR)\n#define MD1 27\n#define MD2 26\n// Delantero Derecho (FR)\n#define MI3 5\n#define MI4 18\n// Delantero Izquierdo (FL)\n#define MD3 17\n#define MD4 16\n\n// === (OPCIONAL) Pines de ENABLE del driver ===\n// L298N/L293D: ENA habilita un lado, ENB el otro.\n// Si tu placa ya trae jumpers a 5V, puedes comentar estas 3 l\u00edneas:\n#define ENA 32\n#define ENB 33\n#define USE_ENABLE_PINS 1\n\n// === (OPCIONAL) TB6612FNG (descomenta si lo usas) ===\n// #define STBY 25   // poner HIGH\n// #define USE_TB6612 1\n\nconst int motores[] = { MI1, MI2, MD1, MD2, MI3, MI4, MD3, MD4 };\n\n// ======== Bluepad32 ========\nGamepadPtr pads[BP32_MAX_GAMEPADS];\n\n// Deadzone m\u00e1s chica\nconst int DEADZONE = 80;\n\n// ================== PROTOTIPOS ==================\nvoid avanza();\nvoid atras();\nvoid izquierda();\nvoid derecha();\nvoid diagonal_derecha();\nvoid diagonal_izquierda();\nvoid horizontal_derecha();\nvoid horizontal_izquierda();\nvoid giro_rotacional();\nvoid detener();\n\n// ================== CALLBACKS BLUEPAD ==================\nvoid onConnectedGamepad(GamepadPtr gp) {\n  Serial.println(\"Gamepad conectado!\");\n  for (int i = 0; i &lt; BP32_MAX_GAMEPADS; i++) {\n    if (!pads[i]) { pads[i] = gp; break; }\n  }\n}\nvoid onDisconnectedGamepad(GamepadPtr gp) {\n  Serial.println(\"Gamepad desconectado!\");\n  for (int i = 0; i &lt; BP32_MAX_GAMEPADS; i++) {\n    if (pads[i] == gp) { pads[i] = nullptr; break; }\n  }\n}\n\n// ================== SETUP ==================\nvoid setup() {\n  Serial.begin(115200);\n\n  for (int i = 0; i &lt; 8; i++) pinMode(motores[i], OUTPUT);\n  detener();\n\n  // Habilita driver\n  #ifdef USE_TB6612\n    pinMode(STBY, OUTPUT);\n    digitalWrite(STBY, HIGH);   // TB6612: salir de standby\n  #endif\n  #ifdef USE_ENABLE_PINS\n    pinMode(ENA, OUTPUT);\n    pinMode(ENB, OUTPUT);\n    digitalWrite(ENA, HIGH);    // habilita lado A (puedes usar PWM luego)\n    digitalWrite(ENB, HIGH);    // habilita lado B\n  #endif\n\n  BP32.setup(&amp;onConnectedGamepad, &amp;onDisconnectedGamepad);\n  BP32.enableNewBluetoothConnections(true);\n\n  Serial.println(\"Listo. Motores + Bluepad32 inicializados.\");\n  Serial.println(\"Pon el control de Xbox en modo vinculaci\u00f3n (bot\u00f3n pair).\");\n}\n\n// ================== LOOP ==================\nvoid loop() {\n  BP32.update();\n\n  bool hayAccion = false;\n\n  for (int i = 0; i &lt; BP32_MAX_GAMEPADS; i++) {\n    GamepadPtr gp = pads[i];\n    if (!gp || !gp-&gt;isConnected()) continue;\n\n    int lx = gp-&gt;axisX();   // -511 .. 511\n    int ly = gp-&gt;axisY();\n    int rx = gp-&gt;axisRX();\n\n    // Debug b\u00e1sico\n    static uint32_t tLast = 0;\n    if (millis() - tLast &gt; 250) {\n      tLast = millis();\n      Serial.print(\"LX:\"); Serial.print(lx);\n      Serial.print(\"  LY:\"); Serial.print(ly);\n      Serial.print(\"  RX:\"); Serial.print(rx);\n      Serial.print(\"  DPad:\"); Serial.println(gp-&gt;dpad(), HEX);\n    }\n\n    // Bot\u00f3n B: test r\u00e1pido para comprobar que el driver recibe se\u00f1al\n    if (gp-&gt;b()) {\n      Serial.println(\"TEST: avanza 1s\");\n      avanza();\n      delay(1000);\n      detener();\n      delay(200);\n      hayAccion = true;\n      break;\n    }\n\n    // Bot\u00f3n A: detener\n    if (gp-&gt;a()) { Serial.println(\"DETENER\"); detener(); hayAccion = true; break; }\n\n    // D-Pad: acciones discretas prioritarias\n    uint8_t d = gp-&gt;dpad();\n    if (d) {\n      if (d &amp; DPAD_UP &amp;&amp; d &amp; DPAD_RIGHT)      { Serial.println(\"DIAG DER\"); diagonal_derecha(); }\n      else if (d &amp; DPAD_UP &amp;&amp; d &amp; DPAD_LEFT)  { Serial.println(\"DIAG IZQ\"); diagonal_izquierda(); }\n      else if (d &amp; DPAD_RIGHT)                { Serial.println(\"HORIZ DER\"); horizontal_derecha(); }\n      else if (d &amp; DPAD_LEFT)                 { Serial.println(\"HORIZ IZQ\"); horizontal_izquierda(); }\n      else if (d &amp; DPAD_UP)                   { Serial.println(\"AVANZA\"); avanza(); }\n      else if (d &amp; DPAD_DOWN)                 { Serial.println(\"ATRAS\"); atras(); }\n      hayAccion = true;\n      break;\n    }\n\n    // Sticks anal\u00f3gicos\n    bool movY = abs(ly) &gt; DEADZONE;\n    bool movX = abs(lx) &gt; DEADZONE;\n    bool rot  = abs(rx) &gt; DEADZONE;\n\n    if (rot) {\n      Serial.println(rx &gt; 0 ? \"GIRO -&gt;\" : \"GIRO &lt;-\");\n      giro_rotacional();  // si quieres sentido opuesto, crea otra funci\u00f3n invertida\n      hayAccion = true;\n      break;\n    }\n\n    if (movY &amp;&amp; !movX) {\n      Serial.println(ly &lt; 0 ? \"AVANZA\" : \"ATRAS\");\n      if (ly &lt; 0) avanza(); else atras();\n      hayAccion = true;\n      break;\n    }\n\n    if (movX &amp;&amp; !movY) {\n      Serial.println(lx &gt; 0 ? \"HORIZ DER\" : \"HORIZ IZQ\");\n      if (lx &gt; 0) horizontal_derecha(); else horizontal_izquierda();\n      hayAccion = true;\n      break;\n    }\n\n    if (movX &amp;&amp; movY) {\n      Serial.println(lx &gt; 0 ? \"DIAG DER\" : \"DIAG IZQ\");\n      if (lx &gt; 0) diagonal_derecha(); else diagonal_izquierda();\n      hayAccion = true;\n      break;\n    }\n  }\n\n  if (!hayAccion) detener();\n\n  delay(10);\n}\n\n// ================== FUNCIONES DE CONTROL ==================\nvoid MIARRIBA1() { digitalWrite(MI1, HIGH); digitalWrite(MI2, LOW); }\nvoid MIABAJO1()  { digitalWrite(MI3, HIGH); digitalWrite(MI4, LOW); }\nvoid MDARRIBA1() { digitalWrite(MD1, HIGH); digitalWrite(MD2, LOW); }\nvoid MDABAJO1()  { digitalWrite(MD3, HIGH); digitalWrite(MD4, LOW); }\n\nvoid MIARRIBA0() { digitalWrite(MI1, LOW); digitalWrite(MI2, HIGH); }\nvoid MIABAJO0()  { digitalWrite(MI3, LOW); digitalWrite(MI4, HIGH); }\nvoid MDARRIBA0() { digitalWrite(MD1, LOW); digitalWrite(MD2, HIGH); }\nvoid MDABAJO0()  { digitalWrite(MD3, LOW); digitalWrite(MD4, HIGH); }\n\nvoid avanza() { MIARRIBA1(); MIABAJO1(); MDARRIBA1(); MDABAJO1(); }\nvoid atras()  { MIARRIBA0(); MIABAJO0(); MDARRIBA0(); MDABAJO0(); }\nvoid izquierda() {\n  MIARRIBA0(); MIABAJO1();\n  MDARRIBA0(); MDABAJO1();\n}\nvoid derecha() {\n  MIARRIBA1(); MIABAJO0();\n  MDARRIBA0(); MDABAJO1();\n}\nvoid diagonal_derecha() {\n  digitalWrite(MI1, HIGH); digitalWrite(MI2, LOW);\n  digitalWrite(MD1, LOW);  digitalWrite(MD2, LOW);\n  digitalWrite(MI3, LOW);  digitalWrite(MI4, LOW);\n  digitalWrite(MD3, HIGH); digitalWrite(MD4, LOW);\n}\nvoid diagonal_izquierda() {\n  digitalWrite(MI1, LOW);  digitalWrite(MI2, LOW);\n  digitalWrite(MD1, HIGH); digitalWrite(MD2, LOW);\n  digitalWrite(MI3, HIGH); digitalWrite(MI4, LOW);\n  digitalWrite(MD3, LOW);  digitalWrite(MD4, LOW);\n}\nvoid horizontal_derecha() {\n  digitalWrite(MI1, HIGH); digitalWrite(MI2, LOW);\n  digitalWrite(MD1, LOW);  digitalWrite(MD2, HIGH);\n  digitalWrite(MI3, LOW);  digitalWrite(MI4, HIGH);\n  digitalWrite(MD3, HIGH); digitalWrite(MD4, LOW);\n}\nvoid horizontal_izquierda() {\n  digitalWrite(MI1, LOW);  digitalWrite(MI2, HIGH);\n  digitalWrite(MD1, HIGH); digitalWrite(MD2, LOW);\n  digitalWrite(MI3, HIGH); digitalWrite(MI4, LOW);\n  digitalWrite(MD3, LOW);  digitalWrite(MD4, HIGH);\n}\nvoid giro_rotacional() {\n  digitalWrite(MI1, HIGH); digitalWrite(MI2, LOW);\n  digitalWrite(MD1, LOW);  digitalWrite(MD2, HIGH);\n  digitalWrite(MI3, HIGH); digitalWrite(MI4, LOW);\n  digitalWrite(MD3, LOW);  digitalWrite(MD4, HIGH);\n}\nvoid detener() {\n  for (int i = 0; i &lt; 8; i++) digitalWrite(motores[i],\u00a0LOW);\n}\n</code></pre> <p>Video Uso del programa</p>"},{"location":"Proyecto%203/#codigo-para-el-movimiento-de-las-llantas-omnidireccionales","title":"C\u00f3digo para el movimiento de las llantas omnidireccionales","text":"<pre><code>// ====== Control 4xM con Xbox (Bluepad32 + ESP32) ======\n#include &lt;Bluepad32.h&gt;\n\n// ================== Pines actualizados ==================\n// Trasero Izquierdo (RL)\n#define MI1 12\n#define MI2 14\n// Trasero Derecho (RR)\n#define MD1 27\n#define MD2 26\n// Delantero Derecho (FR)\n#define MI3 5\n#define MI4 18\n// Delantero Izquierdo (FL)\n#define MD3 17\n#define MD4 16\n\n// === (OPCIONAL) Pines de ENABLE del driver ===\n// L298N/L293D: ENA habilita un lado, ENB el otro.\n// Si tu placa ya trae jumpers a 5V, puedes comentar estas 3 l\u00edneas:\n#define ENA 32\n#define ENB 33\n#define USE_ENABLE_PINS 1\n\n// === (OPCIONAL) TB6612FNG (descomenta si lo usas) ===\n// #define STBY 25   // poner HIGH\n// #define USE_TB6612 1\n\nconst int motores[] = { MI1, MI2, MD1, MD2, MI3, MI4, MD3, MD4 };\n\n// ======== Bluepad32 ========\nGamepadPtr pads[BP32_MAX_GAMEPADS];\n\n// Deadzone m\u00e1s chica\nconst int DEADZONE = 80;\n\n// ================== PROTOTIPOS ==================\nvoid avanza();\nvoid atras();\nvoid izquierda();\nvoid derecha();\nvoid diagonal_derecha();\nvoid diagonal_izquierda();\nvoid horizontal_derecha();\nvoid horizontal_izquierda();\nvoid giro_rotacional();\nvoid detener();\n\n// ================== CALLBACKS BLUEPAD ==================\nvoid onConnectedGamepad(GamepadPtr gp) {\n  Serial.println(\"Gamepad conectado!\");\n  for (int i = 0; i &lt; BP32_MAX_GAMEPADS; i++) {\n    if (!pads[i]) { pads[i] = gp; break; }\n  }\n}\nvoid onDisconnectedGamepad(GamepadPtr gp) {\n  Serial.println(\"Gamepad desconectado!\");\n  for (int i = 0; i &lt; BP32_MAX_GAMEPADS; i++) {\n    if (pads[i] == gp) { pads[i] = nullptr; break; }\n  }\n}\n\n// ================== SETUP ==================\nvoid setup() {\n  Serial.begin(115200);\n\n  for (int i = 0; i &lt; 8; i++) pinMode(motores[i], OUTPUT);\n  detener();\n\n  // Habilita driver\n  #ifdef USE_TB6612\n    pinMode(STBY, OUTPUT);\n    digitalWrite(STBY, HIGH);   // TB6612: salir de standby\n  #endif\n  #ifdef USE_ENABLE_PINS\n    pinMode(ENA, OUTPUT);\n    pinMode(ENB, OUTPUT);\n    digitalWrite(ENA, HIGH);    // habilita lado A (puedes usar PWM luego)\n    digitalWrite(ENB, HIGH);    // habilita lado B\n  #endif\n\n  BP32.setup(&amp;onConnectedGamepad, &amp;onDisconnectedGamepad);\n  BP32.enableNewBluetoothConnections(true);\n\n  Serial.println(\"Listo. Motores + Bluepad32 inicializados.\");\n  Serial.println(\"Pon el control de Xbox en modo vinculaci\u00f3n (bot\u00f3n pair).\");\n}\n\n// ================== LOOP ==================\nvoid loop() {\n  BP32.update();\n\n  bool hayAccion = false;\n\n  for (int i = 0; i &lt; BP32_MAX_GAMEPADS; i++) {\n    GamepadPtr gp = pads[i];\n    if (!gp || !gp-&gt;isConnected()) continue;\n\n    int lx = gp-&gt;axisX();   // -511 .. 511\n    int ly = gp-&gt;axisY();\n    int rx = gp-&gt;axisRX();\n\n    // Debug b\u00e1sico\n    static uint32_t tLast = 0;\n    if (millis() - tLast &gt; 250) {\n      tLast = millis();\n      Serial.print(\"LX:\"); Serial.print(lx);\n      Serial.print(\"  LY:\"); Serial.print(ly);\n      Serial.print(\"  RX:\"); Serial.print(rx);\n      Serial.print(\"  DPad:\"); Serial.println(gp-&gt;dpad(), HEX);\n    }\n\n    // Bot\u00f3n B: test r\u00e1pido para comprobar que el driver recibe se\u00f1al\n    if (gp-&gt;b()) {\n      Serial.println(\"TEST: avanza 1s\");\n      avanza();\n      delay(1000);\n      detener();\n      delay(200);\n      hayAccion = true;\n      break;\n    }\n\n    // Bot\u00f3n A: detener\n    if (gp-&gt;a()) { Serial.println(\"DETENER\"); detener(); hayAccion = true; break; }\n\n    // D-Pad: acciones discretas prioritarias\n    uint8_t d = gp-&gt;dpad();\n    if (d) {\n      if (d &amp; DPAD_UP &amp;&amp; d &amp; DPAD_RIGHT)      { Serial.println(\"DIAG DER\"); diagonal_derecha(); }\n      else if (d &amp; DPAD_UP &amp;&amp; d &amp; DPAD_LEFT)  { Serial.println(\"DIAG IZQ\"); diagonal_izquierda(); }\n      else if (d &amp; DPAD_RIGHT)                { Serial.println(\"HORIZ DER\"); horizontal_derecha(); }\n      else if (d &amp; DPAD_LEFT)                 { Serial.println(\"HORIZ IZQ\"); horizontal_izquierda(); }\n      else if (d &amp; DPAD_UP)                   { Serial.println(\"AVANZA\"); avanza(); }\n      else if (d &amp; DPAD_DOWN)                 { Serial.println(\"ATRAS\"); atras(); }\n      hayAccion = true;\n      break;\n    }\n\n    // Sticks anal\u00f3gicos\n    bool movY = abs(ly) &gt; DEADZONE;\n    bool movX = abs(lx) &gt; DEADZONE;\n    bool rot  = abs(rx) &gt; DEADZONE;\n\n    if (rot) {\n      Serial.println(rx &gt; 0 ? \"GIRO -&gt;\" : \"GIRO &lt;-\");\n      giro_rotacional();  // si quieres sentido opuesto, crea otra funci\u00f3n invertida\n      hayAccion = true;\n      break;\n    }\n\n    if (movY &amp;&amp; !movX) {\n      Serial.println(ly &lt; 0 ? \"AVANZA\" : \"ATRAS\");\n      if (ly &lt; 0) avanza(); else atras();\n      hayAccion = true;\n      break;\n    }\n\n    if (movX &amp;&amp; !movY) {\n      Serial.println(lx &gt; 0 ? \"HORIZ DER\" : \"HORIZ IZQ\");\n      if (lx &gt; 0) horizontal_derecha(); else horizontal_izquierda();\n      hayAccion = true;\n      break;\n    }\n\n    if (movX &amp;&amp; movY) {\n      Serial.println(lx &gt; 0 ? \"DIAG DER\" : \"DIAG IZQ\");\n      if (lx &gt; 0) diagonal_derecha(); else diagonal_izquierda();\n      hayAccion = true;\n      break;\n    }\n  }\n\n  if (!hayAccion) detener();\n\n  delay(10);\n}\n\n// ================== FUNCIONES DE CONTROL ==================\nvoid MIARRIBA1() { digitalWrite(MI1, HIGH); digitalWrite(MI2, LOW); }\nvoid MIABAJO1()  { digitalWrite(MI3, HIGH); digitalWrite(MI4, LOW); }\nvoid MDARRIBA1() { digitalWrite(MD1, HIGH); digitalWrite(MD2, LOW); }\nvoid MDABAJO1()  { digitalWrite(MD3, HIGH); digitalWrite(MD4, LOW); }\n\nvoid MIARRIBA0() { digitalWrite(MI1, LOW); digitalWrite(MI2, HIGH); }\nvoid MIABAJO0()  { digitalWrite(MI3, LOW); digitalWrite(MI4, HIGH); }\nvoid MDARRIBA0() { digitalWrite(MD1, LOW); digitalWrite(MD2, HIGH); }\nvoid MDABAJO0()  { digitalWrite(MD3, LOW); digitalWrite(MD4, HIGH); }\n\nvoid avanza() { MIARRIBA1(); MIABAJO1(); MDARRIBA1(); MDABAJO1(); }\nvoid atras()  { MIARRIBA0(); MIABAJO0(); MDARRIBA0(); MDABAJO0(); }\nvoid izquierda() {\n  MIARRIBA0(); MIABAJO1();\n  MDARRIBA0(); MDABAJO1();\n}\nvoid derecha() {\n  MIARRIBA1(); MIABAJO0();\n  MDARRIBA0(); MDABAJO1();\n}\nvoid diagonal_derecha() {\n  digitalWrite(MI1, HIGH); digitalWrite(MI2, LOW);\n  digitalWrite(MD1, LOW);  digitalWrite(MD2, LOW);\n  digitalWrite(MI3, LOW);  digitalWrite(MI4, LOW);\n  digitalWrite(MD3, HIGH); digitalWrite(MD4, LOW);\n}\nvoid diagonal_izquierda() {\n  digitalWrite(MI1, LOW);  digitalWrite(MI2, LOW);\n  digitalWrite(MD1, HIGH); digitalWrite(MD2, LOW);\n  digitalWrite(MI3, HIGH); digitalWrite(MI4, LOW);\n  digitalWrite(MD3, LOW);  digitalWrite(MD4, LOW);\n}\nvoid horizontal_derecha() {\n  digitalWrite(MI1, HIGH); digitalWrite(MI2, LOW);\n  digitalWrite(MD1, LOW);  digitalWrite(MD2, HIGH);\n  digitalWrite(MI3, LOW);  digitalWrite(MI4, HIGH);\n  digitalWrite(MD3, HIGH); digitalWrite(MD4, LOW);\n}\nvoid horizontal_izquierda() {\n  digitalWrite(MI1, LOW);  digitalWrite(MI2, HIGH);\n  digitalWrite(MD1, HIGH); digitalWrite(MD2, LOW);\n  digitalWrite(MI3, HIGH); digitalWrite(MI4, LOW);\n  digitalWrite(MD3, LOW);  digitalWrite(MD4, HIGH);\n}\nvoid giro_rotacional() {\n  digitalWrite(MI1, HIGH); digitalWrite(MI2, LOW);\n  digitalWrite(MD1, LOW);  digitalWrite(MD2, HIGH);\n  digitalWrite(MI3, HIGH); digitalWrite(MI4, LOW);\n  digitalWrite(MD3, LOW);  digitalWrite(MD4, HIGH);\n}\nvoid detener() {\n  for (int i = 0; i &lt; 8; i++) digitalWrite(motores[i],\u00a0LOW);\n}\n</code></pre> <p>Video Uso del programa</p> <p>Video 2</p>"},{"location":"Proyecto%203/#diseno-de-la-base-para-el-carro","title":"Dise\u00f1o de la base para el carro","text":"<p>Dise\u00f1amos el carro en solidwords dejando las medidas de las llantas y colocando agujeros en toda la pieza con la finalidad de pasar cables, adem\u00e1s de dejar ranuras donde se va a ensamblar el carro usando unas paredes que se le adaptaron unos orificios para conectar los motores con la estructura usando tornillos.</p>"},{"location":"Proyecto%203/#modelos-para-corte-laser-en-dxf","title":"Modelos para corte laser en dxf","text":"<p>Base carro.DXF</p> <p>Paredes carro.DXF</p> <p></p>"},{"location":"Proyecto%203/#video-de-resultado-final","title":"Video de resultado final","text":"<p>Resultado final</p> <p></p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Proyecto%20plataforma%20stewart/Balanza/","title":"Plataforma Stewart - An\u00e1lisis Completo","text":""},{"location":"Proyecto%20plataforma%20stewart/Balanza/#1-objetivo-del-sistema","title":"1. Objetivo del sistema","text":"<p>El sistema busca mantener una pelota roja en el centro de un plato circular montado sobre una plataforma tipo Stewart con 3 servos distribuidos a 120\u00b0. La c\u00e1mara detecta plato y pelota; el c\u00f3digo en Python calcula la inclinaci\u00f3n necesaria mediante PID y cinem\u00e1tica inversa; el ESP32 ejecuta los \u00e1ngulos recibidos y mueve los servos.</p> <p>En la interfaz principal (Deteccion_final.jpg) se observa:</p> <p></p> <p>Se ve: - Plato detectado (borde verde). - Centro del plato con c\u00edrculo amarillo/naranja y zona muerta. - Pelota roja con l\u00ednea azul hacia el centro. - HUD con <code>Kp, Ki, Kd</code>, rangos de \u00e1ngulos, \u00e1ngulos actuales y errores normalizados.</p>"},{"location":"Proyecto%20plataforma%20stewart/Balanza/#2-deteccion-del-plato-houghcircles-y-mascara-circular","title":"2. Detecci\u00f3n del plato (HoughCircles) y m\u00e1scara circular","text":"<p>El plato se detecta con <code>cv2.HoughCircles</code> sobre una imagen en escalar de grises suavizada:</p> <ul> <li>Conversi\u00f3n y suavizado:</li> <li><code>gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</code></li> <li> <p><code>blurred = cv2.GaussianBlur(gray, (5,5), 0)</code></p> </li> <li> <p>Par\u00e1metros Hough:</p> </li> <li><code>dp = 0.8</code>: el acumulador de Hough tiene 80% de la resoluci\u00f3n, buena precisi\u00f3n sin ser tan pesado.</li> <li><code>minDist = 280</code>: asegura que solo se detecte un c\u00edrculo grande, evita dobles detecciones.</li> <li><code>param1 = 165</code>: umbral alto de Canny, solo se usan bordes muy definidos (borde del plato).</li> <li><code>param2 = 15</code>: votos m\u00ednimos en el acumulador; bajar este valor hace que aparezcan muchos falsos c\u00edrculos, subirlo hace que deje de detectar.</li> <li><code>minRadius = 130</code>, <code>maxRadius = 211</code>: rango de radios aproximado para el plato.</li> </ul> <p>Se elige el c\u00edrculo de mayor radio de la lista de candidatos; si hay ruido o sombras, estos par\u00e1metros hacen que aun as\u00ed el borde m\u00e1s grande sea el del plato.</p> <p>Para que el c\u00edrculo no \u201csalte\u201d entre cuadros, se aplica un filtro exponencial:</p> <ul> <li><code>plato_cx_f = \u03b1*plato_cx + (1-\u03b1)*plato_cx_f</code> con <code>\u03b1 = 0.9</code>.</li> <li>Esto significa 90% de nuevo valor, 10% de historia; la posici\u00f3n se suaviza pero responde r\u00e1pido.</li> </ul> <p>Con el centro y radio filtrados se genera la m\u00e1scara circular:</p> <ul> <li>M\u00e1scara en blanco y negro del tama\u00f1o del frame, con un c\u00edrculo blanco en la zona del plato y el resto negro.</li> <li>Se usa <code>cv2.bitwise_and</code> para dejar negro todo lo que est\u00e9 fuera del plato; esto garantiza que la detecci\u00f3n de la pelota se haga solo sobre el \u00e1rea \u00fatil.</li> </ul> <p>Se dibujan dos c\u00edrculos:</p> <ul> <li>Uno con radio <code>plato_r_f</code> (borde verde).</li> <li>Uno interno con radio peque\u00f1o, la zona muerta del centro (amarillo/naranja); si la pelota cae dentro, el sistema no corrige para no oscilar.</li> </ul>"},{"location":"Proyecto%20plataforma%20stewart/Balanza/#3-deteccion-de-la-pelota-roja-y-calculo-del-error","title":"3. Detecci\u00f3n de la pelota roja y c\u00e1lculo del error","text":"<p>Con el frame enmascarado, se detecta el color rojo usando espacio HSV:</p> <ul> <li>Se definen dos rangos de rojo:</li> <li><code>[0, 150, 50]</code> a <code>[8, 255, 255]</code> (rojo bajo).</li> <li><code>[170, 150, 50]</code> a <code>[179, 255, 255]</code> (rojo alto).</li> <li>Se hace <code>inRange</code> para cada rango y luego se suman las m\u00e1scaras.</li> </ul> <p>Para reducir ruido:</p> <ul> <li>Se aplica una apertura morfol\u00f3gica (OPEN) con kernel el\u00edptico 5x5 que elimina peque\u00f1as manchas blancas.</li> <li>Se aplica cierre (CLOSE) con el mismo kernel para unir huecos dentro de la mancha de la pelota.</li> </ul> <p>Posteriormente:</p> <ul> <li>Se buscan contornos y se filtran por \u00e1rea (por ejemplo, entre 100 y 5000 p\u00edxeles).</li> <li>De los contornos v\u00e1lidos se escoge el de mayor \u00e1rea como la pelota.</li> <li>Se calculan los momentos de ese contorno y su centroide <code>(cx, cy)</code>.</li> </ul> <p>El error en p\u00edxeles se define como:</p> <ul> <li><code>errX_raw = cx - plato_cx_f</code> (positivo si la pelota est\u00e1 a la derecha).</li> <li><code>errY_raw = cy - plato_cy_f</code> (positivo si la pelota est\u00e1 hacia abajo).</li> </ul> <p>Para que el error sea independiente del tama\u00f1o f\u00edsico del plato:</p> <ul> <li>Se divide por el radio filtrado <code>plato_r_f</code>, obteniendo:</li> <li><code>errX_norm = errX_raw / plato_r_f</code>.</li> <li><code>errY_norm = errY_raw / plato_r_f</code>.</li> <li>Esto produce un error normalizado en el rango aproximado <code>[-1, +1]</code>, donde 1 significa que la pelota est\u00e1 al borde del plato en una direcci\u00f3n dada.</li> </ul> <p>Estos errores normalizados se filtran suavemente:</p> <ul> <li><code>errX_f = \u03b1_err*errX_norm + (1-\u03b1_err)*errX_f</code> con <code>\u03b1_err = 0.6</code>.</li> <li>El error filtrado reacciona r\u00e1pido a cambios pero sin a\u00f1adir demasiado ruido al PID.</li> </ul> <p>Si la pelota sale del plato o ya no se detecta:</p> <ul> <li>El error se pone a cero.</li> <li>Se resetean las integrales y errores previos del PID para evitar windup (acumulaci\u00f3n excesiva de integral).</li> </ul>"},{"location":"Proyecto%20plataforma%20stewart/Balanza/#4-control-pid-y-zona-muerta","title":"4. Control PID y zona muerta","text":"<p>Cada eje (X e Y) utiliza un PID discreto con ganancia ajustable en tiempo real mediante los slicers de la ventana \u201cPID Tuner\u201d (<code>Slicer_PID.jpg</code>):</p> <p></p> <p>En el loop:</p> <ul> <li>Se leen los valores de tres trackbars:</li> <li><code>\"Kp x10\"</code> \u2192 <code>Kp = slider / 10.0</code>.</li> <li><code>\"Ki x100\"</code> \u2192 <code>Ki = slider / 100.0</code>.</li> <li><code>\"Kd x10\"</code> \u2192 <code>Kd = slider / 10.0</code>.</li> <li>Estos se asignan a <code>pid_x</code> y <code>pid_y</code>, por lo que se puede afinar el controlador sin recompilar.</li> </ul> <p>El PID calcula:</p> <ul> <li><code>output = Kp*e + Ki*integral + Kd*derivative</code> con:</li> <li>Anti-windup: la integral est\u00e1 limitada a un rango como <code>[-50, 50]</code>.</li> <li>Saturaci\u00f3n de la salida: por ejemplo, <code>[-20, +20]</code> grados de inclinaci\u00f3n m\u00e1ximos.</li> </ul> <p>La entrada al PID no es el error normalizado directo, sino escalado:</p> <ul> <li><code>errX_input = errX_f * 100</code>.</li> <li><code>errY_input = errY_f * 100</code>.</li> </ul> <p>Se implementa una zona muerta de error (<code>DEADZONE_ERR_INPUT</code>):</p> <ul> <li>Si <code>abs(errX_input) &lt; DEADZONE_ERR_INPUT</code>, se fuerza <code>errX_input = 0</code>.</li> <li>Esto evita que peque\u00f1as variaciones aleatorias causen correcciones continuas y vibraciones en los servos.</li> </ul> <p>Salida corregida:</p> <ul> <li><code>theta_X = -pid_x.update(errX_input)</code>.</li> <li><code>theta_Y = -pid_y.update(errY_input)</code>.</li> </ul> <p>El signo negativo es clave: el PID ve el error positivo, pero la inclinaci\u00f3n debe ser hacia el lado contrario para que la pelota ruede de vuelta al centro.</p> <p>Finalmente, <code>theta_X</code> y <code>theta_Y</code> se limitan a un rango razonable, por ejemplo <code>[-25, +25]</code> grados.</p>"},{"location":"Proyecto%20plataforma%20stewart/Balanza/#5-cinematica-inversa-de-3-servos-120","title":"5. Cinem\u00e1tica inversa de 3 servos (120\u00b0)","text":"<p>Los tres servos est\u00e1n colocados equidistantes en la base, cada uno separado 120\u00b0 del siguiente. La inclinaci\u00f3n en X e Y de la plataforma se transforma en \u00e1ngulos finales <code>A1</code>, <code>A2</code>, <code>A3</code> de cada servo usando trigonometr\u00eda:</p> <p>Se define un \u00e1ngulo base fijo:</p> <ul> <li><code>BASE_ANGLE</code> (por ejemplo, 50\u00b0) es la posici\u00f3n neutra, donde la plataforma est\u00e1 lo m\u00e1s nivelada posible.</li> <li><code>MIN_ANGLE</code> y <code>MAX_ANGLE</code> definen l\u00edmites duros (como 36\u00b0 y 63\u00b0 en <code>Slicer_grados.jpg</code>).</li> </ul> <p>En la funci\u00f3n de cinem\u00e1tica:</p> <pre><code>angle_1 = BASE_ANGLE + theta_Y\nangle_2 = BASE_ANGLE + (theta_Xcos(30\u00b0)) - (theta_Ysin(30\u00b0))\nangle_3 = BASE_ANGLE - (theta_Xcos(30\u00b0)) - (theta_Ysin(30\u00b0))\n</code></pre> <ul> <li><code>cos(30\u00b0) \u2248 0.866</code>, <code>sin(30\u00b0) = 0.5</code>.</li> <li><code>angle_1</code> responde m\u00e1s a inclinaci\u00f3n en Y (servo \u201cfrontal\u201d).</li> <li><code>angle_2</code> y <code>angle_3</code> combinan X e Y debido a la simetr\u00eda de 120\u00b0.</li> </ul> <p>Despu\u00e9s se hace <code>clip</code> de cada \u00e1ngulo entre <code>MIN_ANGLE</code> y <code>MAX_ANGLE</code>:</p> <ul> <li>As\u00ed el sistema no pide nunca un \u00e1ngulo mec\u00e1nicamente imposible para los servos.</li> </ul> <p>Las posiciones calculadas se mandan al ESP32 como:</p> <pre><code>A1:\u00e1ngulo1,A2:\u00e1ngulo2,A3:\u00e1ngulo3\\n\n</code></pre> <p>El ESP32 interpreta este string, convierte a PWM y actualiza los tres servos.</p> <p>En la ventana \u201cServo Angles\u201d (<code>Slicer_grados.jpg</code>) se pueden ajustar en vivo <code>Base</code>, <code>Min</code> y <code>Max</code>:</p> <p></p> <p>El c\u00f3digo chequea constantemente:</p> <ul> <li>Si <code>Min &gt;= Max</code>, sube <code>Max</code> autom\u00e1ticamente.</li> <li>Si <code>Base</code> sale del rango <code>[Min, Max]</code>, se corrige y se actualiza el slider.</li> </ul> <p>Cada cambio dispara el env\u00edo de una nueva configuraci\u00f3n al ESP32:</p> <pre><code>CFG:BASE:Base,MIN:Min,MAX:Max\\n\n</code></pre>"},{"location":"Proyecto%20plataforma%20stewart/Balanza/#6-trackbars-y-ajuste-en-tiempo-real","title":"6. Trackbars y ajuste en tiempo real","text":"<p>Las ventanas de PID y \u00e1ngulos non solo muestran sliders, sino paneles informativos generados con im\u00e1genes:</p> <ul> <li>Para PID (<code>Slicer_PID.jpg</code>): se dibuja fondo gris y texto grande \u201cKp = xx.xx, Ki = yy.yyy, Kd = zz.zz\u201d.</li> <li>Para \u00e1ngulos (<code>Slicer_grados.jpg</code>): se dibuja texto \u201cBase = 50.0 grados, Min = 36.0 grados, Max = 63.0 grados\u201d.</li> </ul> <p>De esta forma, aunque los sliders est\u00e9n arriba, el usuario ve los valores num\u00e9ricos exactos con decimales.</p>"},{"location":"Proyecto%20plataforma%20stewart/Balanza/#7-piezas-mecanicas-e-impresion-3d","title":"7. Piezas mec\u00e1nicas e impresi\u00f3n 3D","text":"<p>El dise\u00f1o mec\u00e1nico se basa en piezas modeladas en CAD y exportadas a STL. Se muestran varias vistas de las piezas y configuraciones de impresora, por ejemplo:</p> <ul> <li><code>Pieza_1.jpg</code>: muestra un lote de piezas peque\u00f1as (como uniones o brazos cortos) sobre la cama de impresi\u00f3n, con par\u00e1metros de capa y tiempo de impresi\u00f3n.</li> <li><code>Union_2.jpg</code>: otra pieza de uni\u00f3n m\u00e1s larga, tambi\u00e9n en Orca/Bambu Studio, donde se ve altura de capa, anchos de l\u00ednea y tiempo total.</li> <li><code>Base_servos.jpg</code>: representa la base donde se atornillan los servos, con soportes generados solo en algunas zonas verdes.</li> <li><code>Base_superior.jpg</code>: anillo o tapa superior de la plataforma, tambi\u00e9n con soportes definidos y estimaci\u00f3n de tiempo y peso de material.</li> </ul> <p>Ejemplo de c\u00f3mo documentarlas en la nota:</p> <p>  ```</p>"},{"location":"Proyecto%20plataforma%20stewart/Balanza/#8-codigo-completo","title":"8. Codigo completo","text":"<pre><code>import cv2\nimport numpy as np\nimport math\nimport serial\nimport time\n\n\n# ===================== CONFIGURACION SERIAL =====================\nPUERTO_SERIAL = 'COM11' # &lt;-- AJUSTA ESTO AL PUERTO DE TU ESP32\nBAUDRATE = 115200\nTIMEOUT = 0.01\n\n\ntry:\n    arduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\n    time.sleep(2)\n    print(\"\u2713 Serial conectado en\", PUERTO_SERIAL)\nexcept Exception as e:\n    print(f\"\u2717 ERROR: No se pudo conectar en {PUERTO_SERIAL}. {e}\")\n    arduino = None\n\n# ===================== PARAMETROS HOUGH (PLATO) =====================\ndp       = 0.8\nminDist  = 280\nparam1   = 165\nparam2   = 15\nminRadius = 130\nmaxRadius = 211\n\n\n# ===================== FILTRO EXPONENCIAL DEL PLATO =====================\nalpha_plato = 0.9 \nplato_cx_f = plato_cy_f = plato_r_f = None \n\n\n# ===================== COEFICIENTES DE SUAVIZADO DE ERROR =====================\nalpha_err = 0.6\nerrX_f = errY_f = 0.0 \n\n\n# ===================== VIDEO =====================\ncap = cv2.VideoCapture(0)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\n\n# ===================== ANGULOS DE SERVO (INICIALES) =====================\nBASE_ANGLE = 50.0 \nMIN_ANGLE = 30.0  \nMAX_ANGLE = 70.0   \n\n\nCOS_30 = math.cos(math.radians(30)) \nSIN_30 = math.sin(math.radians(30)) \n\n\n# ===================== PID BASICO =====================\nclass PID:\n    def __init__(self, Kp, Ki, Kd, setpoint=0, dt=0.03):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.setpoint = setpoint\n        self.dt = dt\n        self.prev_error = 0\n        self.integral = 0\n\n\n    def update(self, measurement):\n        error = self.setpoint - measurement\n        self.integral += error * self.dt\n        self.integral = np.clip(self.integral, -50, 50) \n        derivative = (error - self.prev_error) / self.dt\n\n        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative\n\n        output = np.clip(output, -20, 20)\n        self.prev_error = error\n        return output\n\n\n# Inicializar PIDs de inclinaci\u00f3n\npid_dt = 0.03 \npid_x = PID(Kp=10.0, Ki=0.2, Kd=1.0, dt=pid_dt) \npid_y = PID(Kp=10.0, Ki=0.2, Kd=1.0, dt=pid_dt)\n\n\n# ===================== CINEM\u00c1TICA DE 3 SERVOS =====================\ndef calcular_angulos_servos(theta_x, theta_y, base_angle, min_angle, max_angle):\n    angle_1 = base_angle + theta_y \n    angle_2 = base_angle + (theta_x * COS_30) - (theta_y * SIN_30)\n    angle_3 = base_angle - (theta_x * COS_30) - (theta_y * SIN_30)\n\n    angle_1 = np.clip(angle_1, min_angle, max_angle)\n    angle_2 = np.clip(angle_2, min_angle, max_angle)\n    angle_3 = np.clip(angle_3, min_angle, max_angle)\n\n    return int(angle_1), int(angle_2), int(angle_3)\n\n\n# ===================== ENVIO DE CONFIGURACION AL ESP32 =====================\ndef enviar_config_angulos(base, min_ang, max_ang):\n    \"\"\"Env\u00eda la configuraci\u00f3n de \u00e1ngulos al ESP32\"\"\"\n    if arduino is not None:\n        try:\n            comando_config = f\"CFG:BASE:{base},MIN:{min_ang},MAX:{max_ang}\\n\"\n            arduino.write(comando_config.encode('ascii'))\n            print(f\"\u2713 Config enviada: BASE={base}\u00b0, MIN={min_ang}\u00b0, MAX={max_ang}\u00b0\")\n        except Exception as e:\n            print(f\"Error al enviar config: {e}\")\n\n\n# ===================== CONFIGURACI\u00d3N DE TRACKBARS =====================\ndef on_trackbar(val):\n    pass\n\n\n# Funci\u00f3n para crear imagen de informaci\u00f3n con valores reales\ndef crear_imagen_info_pid(kp, ki, kd):\n    img = np.zeros((150, 400, 3), dtype=np.uint8)\n    img[:] = (40, 40, 40)  # Fondo gris oscuro\n\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.putText(img, \"VALORES PID ACTUALES\", (70, 30), font, 0.7, (255, 255, 255), 2)\n    cv2.line(img, (20, 40), (380, 40), (100, 100, 100), 1)\n\n    cv2.putText(img, f\"Kp = {kp:.2f}\", (50, 75), font, 0.8, (0, 255, 255), 2)\n    cv2.putText(img, f\"Ki = {ki:.3f}\", (50, 105), font, 0.8, (0, 255, 255), 2)\n    cv2.putText(img, f\"Kd = {kd:.2f}\", (50, 135), font, 0.8, (0, 255, 255), 2)\n\n    return img\n\n\ndef crear_imagen_info_angulos(base, min_ang, max_ang):\n    img = np.zeros((150, 400, 3), dtype=np.uint8)\n    img[:] = (40, 40, 40)  # Fondo gris oscuro\n\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.putText(img, \"ANGULOS DE SERVOS\", (85, 30), font, 0.7, (255, 255, 255), 2)\n    cv2.line(img, (20, 40), (380, 40), (100, 100, 100), 1)\n\n    cv2.putText(img, f\"Base = {base}.0 grados\", (50, 75), font, 0.7, (255, 165, 0), 2)\n    cv2.putText(img, f\"Min  = {min_ang}.0 grados\", (50, 105), font, 0.7, (255, 165, 0), 2)\n    cv2.putText(img, f\"Max  = {max_ang}.0 grados\", (50, 135), font, 0.7, (255, 165, 0), 2)\n\n    return img\n\n\n# Crear ventana de control PID\ncv2.namedWindow(\"PID Tuner\")\ncv2.resizeWindow(\"PID Tuner\", 400, 150)\n\n# Trackbars PID (sin texto de unidades, se muestra en la imagen)\ncv2.createTrackbar(\"Kp x10\", \"PID Tuner\", int(pid_x.Kp * 10), 500, on_trackbar)\ncv2.createTrackbar(\"Ki x100\", \"PID Tuner\", int(pid_x.Ki * 100), 100, on_trackbar)\ncv2.createTrackbar(\"Kd x10\", \"PID Tuner\", int(pid_x.Kd * 10), 50, on_trackbar)\n\n# Crear ventana de control de \u00c1ngulos\ncv2.namedWindow(\"Servo Angles\")\ncv2.resizeWindow(\"Servo Angles\", 400, 150)\n\n# Trackbars de \u00e1ngulos (0-180 grados)\ncv2.createTrackbar(\"Base\", \"Servo Angles\", int(BASE_ANGLE), 180, on_trackbar)\ncv2.createTrackbar(\"Min\", \"Servo Angles\", int(MIN_ANGLE), 180, on_trackbar)\ncv2.createTrackbar(\"Max\", \"Servo Angles\", int(MAX_ANGLE), 180, on_trackbar)\n\n# Enviar configuraci\u00f3n inicial\nenviar_config_angulos(int(BASE_ANGLE), int(MIN_ANGLE), int(MAX_ANGLE))\n\nprint(\"\ud83c\udfaf Detecci\u00f3n de Plato y Errores de Pelota (Fondo Negro)\")\nprint(\"\ud83d\udcd0 Ajusta los \u00e1ngulos en tiempo real con los sliders\")\nprint(\"Presiona 'q' para salir\")\n\n# Variables para detectar cambios en \u00e1ngulos\nprev_base = int(BASE_ANGLE)\nprev_min = int(MIN_ANGLE)\nprev_max = int(MAX_ANGLE)\n\n# Bucle principal de control\nwhile True:\n    # --- LECTURA Y ACTUALIZACI\u00d3N DEL PID ---\n    kp_val = cv2.getTrackbarPos(\"Kp x10\", \"PID Tuner\") / 10.0\n    ki_val = cv2.getTrackbarPos(\"Ki x100\", \"PID Tuner\") / 100.0\n    kd_val = cv2.getTrackbarPos(\"Kd x10\", \"PID Tuner\") / 10.0\n\n    pid_x.Kp, pid_x.Ki, pid_x.Kd = kp_val, ki_val, kd_val\n    pid_y.Kp, pid_y.Ki, pid_y.Kd = kp_val, ki_val, kd_val\n\n    # --- LECTURA DE \u00c1NGULOS DESDE TRACKBARS ---\n    current_base = cv2.getTrackbarPos(\"Base\", \"Servo Angles\")\n    current_min = cv2.getTrackbarPos(\"Min\", \"Servo Angles\")\n    current_max = cv2.getTrackbarPos(\"Max\", \"Servo Angles\")\n\n    # Mostrar valores reales en las ventanas de trackbars\n    img_pid_info = crear_imagen_info_pid(kp_val, ki_val, kd_val)\n    cv2.imshow(\"PID Tuner\", img_pid_info)\n\n    img_angle_info = crear_imagen_info_angulos(current_base, current_min, current_max)\n    cv2.imshow(\"Servo Angles\", img_angle_info)\n\n    # Validar que Min &lt; Base &lt; Max\n    if current_min &gt;= current_max:\n        current_max = current_min + 1\n        cv2.setTrackbarPos(\"Max\", \"Servo Angles\", current_max)\n\n    if current_base &lt; current_min:\n        current_base = current_min\n        cv2.setTrackbarPos(\"Base\", \"Servo Angles\", current_base)\n    elif current_base &gt; current_max:\n        current_base = current_max\n        cv2.setTrackbarPos(\"Base\", \"Servo Angles\", current_base)\n\n    # Detectar cambios y enviar nueva configuraci\u00f3n\n    if (current_base != prev_base or current_min != prev_min or current_max != prev_max):\n        enviar_config_angulos(current_base, current_min, current_max)\n        prev_base, prev_min, prev_max = current_base, current_min, current_max\n\n    # --- RESTO DE L\u00d3GICA DE VISI\u00d3N Y CONTROL ---\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    frame = cv2.flip(frame, 1)\n    frame_display = frame.copy() \n\n    # --- 1) DETECCION DEL PLATO (HOUGH) ---\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    blurred = cv2.GaussianBlur(gray, (5,5), 0)\n    circles = cv2.HoughCircles(\n        blurred, cv2.HOUGH_GRADIENT,\n        dp=dp, minDist=minDist,\n        param1=param1, param2=param2,\n        minRadius=minRadius, maxRadius=maxRadius\n    )\n\n    plato_cx, plato_cy, plato_r = None, None, None\n\n    if circles is not None:\n        circles = np.round(circles[0, :]).astype(\"int\")\n        radios = [r for (_,_,r) in circles]\n        idx = np.argmax(radios)\n        plato_cx, plato_cy, plato_r = circles[idx]\n\n        if plato_cx_f is None:\n            plato_cx_f, plato_cy_f, plato_r_f = plato_cx, plato_cy, plato_r\n        else:\n            plato_cx_f = int(alpha_plato*plato_cx + (1-alpha_plato)*plato_cx_f)\n            plato_cy_f = int(alpha_plato*plato_cy + (1-alpha_plato)*plato_cy_f)\n            plato_r_f  = int(alpha_plato*plato_r + (1-alpha_plato)*plato_r_f)\n\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), plato_r_f, (0,255,0), 3)\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), 6, (0,255,0), -1) # Centro\n\n        # --- NUEVO C\u00cdRCULO: ZONA MUERTA ---\n        DEADZONE_RADIUS = 10 # Radio en p\u00edxeles para la zona muerta (ajusta si es necesario)\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), DEADZONE_RADIUS, (0,165,255), 2)\n\n        cv2.putText(frame_display, f\"PLATO DETECTADO (r={plato_r_f})\", \n                             (plato_cx_f - 120, plato_cy_f - plato_r_f - 10), \n                             cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)\n    else:\n        plato_cx_f = plato_cy_f = plato_r_f = None\n        cv2.putText(frame_display, \"PLATO NO DETECTADO\", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n    # --- A) ENMASCARAMIENTO CIRCULAR (FONDO NEGRO) ---\n    if plato_cx_f is not None:\n        mask_plato = np.zeros(frame.shape[:2], dtype=\"uint8\")\n        cv2.circle(mask_plato, (plato_cx_f, plato_cy_f), plato_r_f - 5, 255, -1) \n        frame_deteccion = cv2.bitwise_and(frame, frame, mask=mask_plato)\n    else:\n        frame_deteccion = frame\n\n    # --- 2) DETECCION PELOTA ROJA (COLOR / CENTROIDE) ---\n    red_low1  = np.array([0, 150, 50], np.uint8)\n    red_high1 = np.array([8, 255, 255], np.uint8)\n    red_low2  = np.array([170, 150, 50], np.uint8)\n    red_high2 = np.array([179, 255, 255], np.uint8)\n\n    hsv = cv2.cvtColor(frame_deteccion, cv2.COLOR_BGR2HSV)\n    mask1 = cv2.inRange(hsv, red_low1, red_high1)\n    mask2 = cv2.inRange(hsv, red_low2, red_high2)\n    mask = cv2.add(mask1, mask2)\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\n    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)\n    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)\n\n    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    mejor_c = None\n    mejor_cx = mejor_cy = 0\n    mejor_area = 0\n\n    for c in contornos:\n        area = cv2.contourArea(c)\n        if 100 &lt; area &lt; 5000:\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx = int(M[\"m10\"]/M[\"m00\"])\n                cy = int(M[\"m01\"]/M[\"m00\"])\n\n                if mejor_c is None or area &gt; mejor_area:\n                    mejor_c, mejor_cx, mejor_cy, mejor_area = c, cx, cy, area\n\n    # --- 3) CALCULO Y SUAVIZADO DE ERROR ---\n    errX_raw = 0.0\n    errY_raw = 0.0\n    pelota_detectada = False\n\n    if mejor_c is not None and plato_cx_f is not None:\n        dist_al_centro = math.hypot(mejor_cx - plato_cx_f, mejor_cy - plato_cy_f)\n\n        if dist_al_centro &lt; plato_r_f:\n            pelota_detectada = True\n\n            errX_raw = mejor_cx - plato_cx_f \n            errY_raw = mejor_cy - plato_cy_f \n\n            if plato_r_f &gt; 0:\n                 errX_norm = errX_raw / plato_r_f\n                 errY_norm = errY_raw / plato_r_f\n            else:\n                 errX_norm, errY_norm = 0.0, 0.0\n\n            errX_f = alpha_err * errX_norm + (1-alpha_err) * errX_f\n            errY_f = alpha_err * errY_norm + (1-alpha_err) * errY_f\n\n            cv2.circle(frame_display, (mejor_cx, mejor_cy), 8, (0,0,255), -1)\n            cv2.line(frame_display, (mejor_cx, mejor_cy), (plato_cx_f, plato_cy_f), (255,0,0), 2)\n\n        else:\n            errX_f, errY_f = 0.0, 0.0\n            # RESETEAR PID cuando no hay pelota\n            pid_x.integral = 0.0\n            pid_y.integral = 0.0\n            pid_x.prev_error = 0.0\n            pid_y.prev_error = 0.0\n    else:\n        errX_f, errY_f = 0.0, 0.0\n        # RESETEAR PID cuando no hay pelota\n        pid_x.integral = 0.0\n        pid_y.integral = 0.0\n        pid_x.prev_error = 0.0\n        pid_y.prev_error = 0.0\n\n    # --- 4) CONTROL PID Y ENV\u00cdO SERIAL (\ud83c\udfaf L\u00d3GICA CORREGIDA) ---\n    errX_input = errX_f * 100\n    errY_input = errY_f * 100\n\n    # Zona muerta para estabilidad\n    DEADZONE_ERR_INPUT = 5.0\n    if abs(errX_input) &lt; DEADZONE_ERR_INPUT:\n        errX_input = 0.0\n    if abs(errY_input) &lt; DEADZONE_ERR_INPUT:\n        errY_input = 0.0\n\n    # \ud83c\udfaf CORRECCI\u00d3N CLAVE: INVERTIR SE\u00d1AL DE CONTROL\n    theta_X = -pid_x.update(errX_input)  # \u2190 NEGATIVO: COMPENSA el error\n    theta_Y = -pid_y.update(errY_input)  # \u2190 NEGATIVO: COMPENSA el error\n\n    # Limitar inclinaciones extremas\n    theta_X = np.clip(theta_X, -25, 25)\n    theta_Y = np.clip(theta_Y, -25, 25)\n\n    A1, A2, A3 = calcular_angulos_servos(theta_X, theta_Y, current_base, current_min, current_max)\n\n    comando = f\"A1:{A1},A2:{A2},A3:{A3}\\n\"\n\n    if arduino is not None:\n        try:\n            arduino.write(comando.encode('ascii'))\n        except Exception as e:\n            print(f\"Error al enviar datos: {e}\")\n\n    # --- 5) HUD FINAL ---\n    font = cv2.FONT_HERSHEY_SIMPLEX\n\n    cv2.putText(frame_display, f\"Kp:{kp_val:.1f} Ki:{ki_val:.2f} Kd:{kd_val:.1f}\", \n                (10, frame_display.shape[0]-120), font, 0.5, (255,255,0), 2)\n\n    cv2.putText(frame_display, f\"Base:{current_base} Min:{current_min} Max:{current_max}\", \n                (10, frame_display.shape[0]-95), font, 0.5, (255,165,0), 2)\n\n    cv2.putText(frame_display, f\"Angulos: A1:{A1} A2:{A2} A3:{A3}\", \n                (10, frame_display.shape[0]-70), font, 0.5, (255,255,0), 2)\n\n    if pelota_detectada:\n        cv2.putText(frame_display, \n                    f'Inclinacion X,Y: ({theta_X:+.1f} deg, {theta_Y:+.1f} deg)', \n                    (10, frame_display.shape[0]-45), font, 0.5, (0,255,0), 2)\n        cv2.putText(frame_display, \n                    f'Error Norm X,Y: ({errX_f:+.2f}, {errY_f:+.2f})', \n                    (10, frame_display.shape[0]-20), font, 0.5, (0,255,255), 2)\n    else:\n        cv2.putText(frame_display, \"PELOTA NO DETECTADA O FUERA DEL PLATO\", \n                    (10, frame_display.shape[0]-20), font, 0.5, (0,165,255), 2)\n\n    cv2.imshow('CONTROL DE BALANZA (PID ACTIVO)', frame_display)\n    cv2.imshow('Imagen de Deteccion (Solo Plato Visible)', frame_deteccion)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\n    time.sleep(pid_dt) \n\n# ===================== LIMPIEZA =====================\nprint(\"\\n\u2713 Sistema cerrado. Centrando Servos...\")\nif arduino is not None:\n    comando_cierre = f\"A1:{current_base},A2:{current_base},A3:{current_base}\\n\"\n    arduino.write(comando_cierre.encode('ascii'))\n    time.sleep(0.5)\n    arduino.close()\n\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"Proyecto%20plataforma%20stewart/Balanza/#9-videos","title":"9. Videos","text":""},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/","title":"Balanza PID 3D - 6 Cuadrantes Polares","text":""},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#objetivo","title":"Objetivo","text":"<p>Crear sistema de seguimiento que divide la imagen en 6 sectores polares de 60\u00b0 m\u00e1s zonas centro superior/inferior, con slicers interactivos para filtrar \u00e1rea y control PID que env\u00eda comandos a Arduino.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#arquitectura-dual-ventana","title":"Arquitectura Dual Ventana","text":"<p>VENTANA 1 'Camera': Video en vivo + 6 radios + detecci\u00f3n polar + PID VENTANA 2 'SLICER': Controles interactivos min/max \u00e1rea</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#1-division-polar-6-cuadrantes","title":"1. Divisi\u00f3n Polar 6 Cuadrantes","text":"<pre><code>def obtener_cuadrante_6(cx, cy, centrox, centroy):\n    dx = cx - centrox; dy = cy - centroy\n    distancia = math.sqrt(dx**2 + dy**2)\n\n    if distancia &lt; 50:  # Zona CENTRO\n        return \"CENTRO_SUP/INF\", 0.0, 0.0, color_amarillo/cyan\n\n    angulo = math.atan2(dy, dx) * 180 / math.pi  # 0\u00b0=derecha\n    if angulo &lt; 0: angulo += 360\n    sector = int(angulo // 60)  # 6 sectores 60\u00b0\n</code></pre> <p>Sectores: 0\u00b0(Der-Rojo), 60\u00b0(Naranja), 120\u00b0(Magenta), 180\u00b0(Cian), 240\u00b0(Rosa), 300\u00b0(Verde)</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#2-errores-normalizados-polares","title":"2. Errores Normalizados Polares","text":"<pre><code>error_magnitud = np.clip(distancia / 250, 0, 1.0)  # 0=centro, 1=borde\nerrorX_norm = (dx / distancia) * error_magnitud\nerrorY_norm = (dy / distancia) * error_magnitud\n</code></pre> <p>Vector unitario \u00d7 magnitud: Error direccional ponderado por distancia.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#3-comunicacion-serial-arduino","title":"3. Comunicaci\u00f3n Serial Arduino","text":"<pre><code>PUERTO_SERIAL = 'COM11'; BAUDRATE = 11520\narduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=0.01)\ntime.sleep(2)  # Reset Arduino\n</code></pre> <p>Comando: \"X:45,Y:-12,Z:78\\n\" \u2192 Servos pines 11,6,5</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#4-controladores-pid-3-ejes","title":"4. Controladores PID (3 ejes)","text":"<pre><code>pid_x = PID(Kp=0.8, Ki=0.05, Kd=0.15)     # Horizontal\npid_y = PID(Kp=0.8, Ki=0.05, Kd=0.15)     # Vertical\npid_area = PID(Kp=0.3, Ki=0.02, Kd=0.08, setpoint=2000)  # Distancia\n</code></pre> <p>Escalado: errorX_norm * 100 \u2192 salida \u00b190\u00b0 servo</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#5-slicers-interactivos-minmax-area","title":"5. Slicers Interactivos (min/max \u00e1rea)","text":"<pre><code>def dibujar_slicer(frame, y_pos, valor, label, min_val, max_val, color):\n    cv2.rectangle(frame, (10, y_pos), (310, y_pos+30), (50,50,50), -1)  # Fondo\n    proporcion = (valor - min_val) / (max_val - min_val)\n    cv2.rectangle(frame, (10, y_pos), (10+int(proporcion*300), y_pos+30), color, -1)\n</code></pre> <p>Controles: Rueda mouse \u2191\u2193 | A/Z:min\u00b1100 | S/X:max\u00b1200</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#6-deteccion-visual-optimizada","title":"6. Detecci\u00f3n Visual Optimizada","text":"<pre><code>hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\nmask1 = cv2.inRange(hsv, [0,150,50], [8,255,255])     # Rojo1\nmask2 = cv2.inRange(hsv, [170,150,50], [179,255,255]) # Rojo2\nmask = cv2.add(mask1, mask2)\n</code></pre> <p>Filtro \u00e1rea: min_area(100)-max_area(8000) elimina ruido/objetos grandes</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#7-visualizacion-6-radios-polares","title":"7. Visualizaci\u00f3n 6 Radios Polares","text":"<pre><code>radio_lineas = 150\nfor angulo in range(0, 360, 60):  # Cada 60\u00b0\n    x_fin = centrox + radio_lineas * math.cos(math.radians(angulo))\n    y_fin = centroy + radio_lineas * math.sin(math.radians(angulo))\n    cv2.line(frame, (centrox, centroy), (x_fin, y_fin), (0,255,0), 2)\n</code></pre> <p>6 l\u00edneas verdes: Dividen imagen en sectores polares precisos.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#8-flujo-principal-dual-ventana","title":"8. Flujo Principal Dual Ventana","text":"<pre><code>while True:\n    frame = cap.read() \u2192 flip(1)\n    # 1. HSV \u2192 Morfolog\u00eda \u2192 Contornos filtrados\n    # 2. Mejor contorno \u2192 cuadrante_6() \u2192 errores normalizados\n    # 3. PID \u2192 outputX/Y/Z \u2192 Serial Arduino\n    # 4. Dibujar: centro+radio50+6lineas+target+cuadrante\n    # 5. frame_slicer \u2192 2 slicers + cursor mouse\n    cv2.imshow('Camera', frame)\n    cv2.imshow('SLICER', frame_slicer)\n</code></pre>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#9-controles-interactivos-completos","title":"9. Controles Interactivos Completos","text":"<p>TECLADO: A/Z: min_area \u00b1100 S/X: max_area \u00b1200 Q: Salir</p> <p>RAT\u00d3N (ventana SLICER): \u2191\u2193Rueda sobre slicer1: min_area \u00b150 \u2191\u2193Rueda sobre slicer2: max_area \u00b1100</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#10-informacion-en-pantalla-tiempo-real","title":"10. Informaci\u00f3n en Pantalla Tiempo Real","text":"<p>CENTRO: C\u00edrculo verde r=10 + borde r=50 (zona CENTRO) TARGET: C\u00edrculo coloreado por cuadrante r=8 RADIO: 6 l\u00edneas verdes 150px cada 60\u00b0 TEXTO: Cuadrante | X/Y_norm | \u00c1rea | PID_XYZ SLICER: min_area(verde) | max_area(naranja)</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#11-limpieza-segura","title":"11. Limpieza Segura","text":"<pre><code>arduino.write(b\"X:0,Y:0,Z:0\\n\")  # Servos neutral\ntime.sleep(0.5)  # Movimiento completo\ncap.release()\narduino.close()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#valores-iniciales-recomendados","title":"Valores Iniciales Recomendados","text":"<p>min_area = 100    # Elimina ruido peque\u00f1o max_area = 8000   # Limita objetos grandes setpoint_area = 2000  # Tama\u00f1o objetivo pelota radio_centro = 50     # Zona muerta central radio_lineas = 150    # Visualizaci\u00f3n sectores</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#problemas-comunes-y-soluciones","title":"Problemas Comunes y Soluciones","text":"Problema Causa Soluci\u00f3n No detecta \u00c1rea fuera rango Ajustar slicers A/Z/S/X Cuadrante err\u00f3neo Pelota en borde \u2191radio_centro (60-80) PID inestable Error muy peque\u00f1o errorX_norm * 150 Servos no responden Serial Verificar COM11/11520"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20cuadrantes/#evidencias","title":"Evidencias","text":""},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/","title":"Calibrador HoughCircles - Plato Circular","text":""},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#objetivo","title":"Objetivo","text":"<p>Crear una interfaz interactiva que permita ajustar en tiempo real los 6 par\u00e1metros de cv2.HoughCircles para detectar platos circulares de forma \u00f3ptima, guardando valores finales para c\u00f3digo principal.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#parametros-houghcircles-explicados","title":"Par\u00e1metros HoughCircles Explicados","text":"Par\u00e1metro Funci\u00f3n Rango t\u00edpico Efecto visual dp Resoluci\u00f3n acumulador (1=imagen, 2=mitad) 0.8-2.0 Precisi\u00f3n vs velocidad minDist Distancia m\u00ednima c\u00edrculos 100-400px Evita detecci\u00f3n m\u00faltiple param1 Umbral Canny (bordes) 50-200 Sensibilidad bordes param2 Umbral acumulador c\u00edrculo 15-60 Confianza detecci\u00f3n minRadius Radio m\u00ednimo c\u00edrculo 80-200px Filtra c\u00edrculos peque\u00f1os maxRadius Radio m\u00e1ximo c\u00edrculo 200-400px Filtra c\u00edrculos grandes"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#1-inicializacion-y-ventana-interactiva","title":"1. Inicializaci\u00f3n y Ventana Interactiva","text":"<pre><code>cap = cv2.VideoCapture(0)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\nventana_calibrador = 'HOUGH CIRCLES CALIBRADOR'\ncv2.namedWindow(ventana_calibrador)\ncv2.setMouseCallback(ventana_calibrador, mouse_callback)\n</code></pre> <ul> <li>640x480: Resoluci\u00f3n fija para slicers consistentes</li> <li>mouse_callback: Detecta rueda del mouse sobre slicers</li> </ul>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#2-frame-slicers-panel-de-control","title":"2. Frame Slicers (Panel de Control)","text":"<pre><code>frame_slicers = np.zeros((480, 640, 3), dtype=np.uint8)\nframe_slicers.fill(30)  # Fondo gris oscuro\n</code></pre> <p>Crea panel negro separado (mismo tama\u00f1o c\u00e1mara) para 6 slicers horizontales.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#3-funcion-dibujar_slicer","title":"3. Funci\u00f3n dibujar_slicer()","text":"<pre><code>def dibujar_slicer(frame, y_pos, valor, label, min_val, max_val, color):\n    # Barra fondo gris\n    cv2.rectangle(frame, (20, y_pos), (620, y_pos+35), (60,60,60), -1)\n    # Barra progreso coloreada\n    proporcion = (valor - min_val) / (max_val - min_val)\n    ancho_activo = int(proporcion * 600)\n    cv2.rectangle(frame, (20, y_pos+5), (20+ancho_activo, y_pos+30), color, -1)\n    # Etiqueta con valor actual\n    cv2.putText(frame, f'{label}: {valor:.1f}', (20, y_pos-8), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)\n</code></pre> <p>Cada slicer: Barra gris + progreso coloreado + texto valor/rango.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#4-deteccion-houghcircles-en-tiempo-real","title":"4. Detecci\u00f3n HoughCircles en Tiempo Real","text":"<pre><code>gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\nblurred = cv2.GaussianBlur(gray, (5, 5), 0)  # Suavizado esencial\n\ncircles = cv2.HoughCircles(\n    blurred, cv2.HOUGH_GRADIENT, \n    dp=float(dp), minDist=int(minDist),\n    param1=int(param1), param2=int(param2),\n    minRadius=int(minRadius), maxRadius=int(maxRadius)\n)\n</code></pre> <p>GaussianBlur(5,5): Elimina ruido antes de Hough (cr\u00edtico).</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#5-seleccion-mejor-circulo","title":"5. Selecci\u00f3n Mejor C\u00edrculo","text":"<pre><code>if circles is not None:\n    circles = np.round(circles[0, :]).astype(\"int\")\n    areas = [r*r for _,_,r in circles]  # \u00c1rea = \u03c0r\u00b2 \u2248 r\u00b2\n    mejor_idx = np.argmax(areas)  # MAYOR = m\u00e1s confiable\n    mejor_plato = circles[mejor_idx]\n</code></pre> <p>Criterio: El c\u00edrculo de mayor radio es el plato principal.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#6-visualizacion-inteligente","title":"6. Visualizaci\u00f3n Inteligente","text":""},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#todos-los-circulos-transparencia-por-confianza","title":"TODOS los c\u00edrculos (transparencia por confianza)","text":"<pre><code>for i, (x, y, r) in enumerate(circles):\n    alpha = 0.3 + 0.7 * (r*r / max(areas))  # Mayor \u00e1rea = m\u00e1s visible\n    color = (0, int(255*alpha), 0)\n    cv2.circle(frame, (x, y), r, color, 2)\n\n# MEJOR PLATO (verde grueso)\ncv2.circle(frame, (x, y), r, (0,255,0), 3)\ncv2.circle(frame, (x, y), 6, (0,255,0), -1)\n</code></pre> <p>Alpha din\u00e1mico: C\u00edrculos peque\u00f1os semitransparentes, grandes=opacos.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#7-controles-interactivos","title":"7. Controles Interactivos","text":""},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#rueda-del-mouse-sobre-slicers","title":"Rueda del Mouse (sobre slicers)","text":"<pre><code>if event == cv2.EVENT_MOUSEWHEEL:\n    delta = 0.05 if event &gt; 0 else -0.05\n    if y_slicer &lt;= y &lt;= y_slicer+33:  # Zona DP\n        dp = np.clip(dp + delta, 0.8, 2.0)\n</code></pre>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#teclado-rapido","title":"Teclado r\u00e1pido","text":"<p>Q/A: dp \u00b10.1    D/E: minDist \u00b120 Z/X: param1 \u00b110  C/V: param2 \u00b15 B/N: minR \u00b110    ,/.: maxR \u00b120 ESPACIO: Guardar  ESC: Salir</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#8-interfaz-combinada","title":"8. Interfaz Combinada","text":"<pre><code>frame_combinado = np.hstack([frame, frame_slicers])  # Izquierda=Derecha\ncv2.imshow(ventana_calibrador, frame_combinado)\n</code></pre> <p>hstack: C\u00e1mara (640px) + Slicers (640px) = 1280px ancho.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#9-guardado-valores-optimos","title":"9. Guardado Valores \u00d3ptimos","text":"<pre><code>if tecla == 32:  # ESPACIO\n    valores_optimos = {'dp': dp, 'minDist': minDist, ...}\n    print(\"\u2705 VALORES \u00d3PTIMOS GUARDADOS:\")\n</code></pre> <p>Salida lista para copiar a c\u00f3digo principal HoughCircles.</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#10-valores-iniciales-recomendados","title":"10. Valores Iniciales Recomendados","text":"<p>dp = 1.2        # Resoluci\u00f3n media minDist = 200   # Platos ~20cm separados param1 = 100    # Bordes medios param2 = 30     # Confianza media minRadius = 120 # Platos ~12cm di\u00e1metro maxRadius = 300 # Hasta ~30cm</p>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#uso-practico","title":"Uso Pr\u00e1ctico","text":"<ol> <li>Ejecutar calibrador \u2192 apuntar c\u00e1mara a platos</li> <li>Ajustar slicers con rueda/teclado hasta detectar 1 c\u00edrculo verde grueso</li> <li>ESPACIO \u2192 copiar valores impresos</li> <li>Pegar en c\u00f3digo principal:</li> </ol> <pre><code>circles = cv2.HoughCircles(blurred, cv2.HOUGH_GRADIENT, \n    dp=1.2, minDist=200, param1=100, param2=30, \n    minRadius=120, maxRadius=300)\n</code></pre>"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#problemas-comunes","title":"Problemas Comunes","text":"S\u00edntoma Soluci\u00f3n Demasiados c\u00edrculos \u2191minDist, \u2193param2 No detecta plato \u2193param1, \u2191param2, \u2193dp C\u00edrculos muy peque\u00f1os \u2191minRadius Demasiado lento \u2191dp (1.5-2.0) Bordes ruidosos GaussianBlur(7,7)"},{"location":"Proyecto%20plataforma%20stewart/Calibracion%20de%20plataforma/#evidencias","title":"Evidencias","text":""},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/","title":"Balanza PID 3D - OpenCV + Arduino","text":""},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#objetivo","title":"Objetivo","text":"<p>Crear una plataforma aut\u00f3noma que siga un objeto de color espec\u00edfico moviendo 3 servos usando visi\u00f3n por computadora y control PID avanzado.</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#1-inicializacion-camara-cv2videocapture","title":"1. Inicializaci\u00f3n C\u00e1mara (cv2.VideoCapture)","text":""},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#por-que-videocapture0","title":"\u00bfPor qu\u00e9 VideoCapture(0)?","text":"<pre><code>cap = cv2.VideoCapture(0) # 0 = c\u00e1mara predeterminada (webcam)\n</code></pre> <ul> <li><code>0</code> = primera c\u00e1mara detectada (webcam USB/interna)</li> <li><code>1</code> = segunda c\u00e1mara, etc.</li> <li>IMPORTANTE: Siempre cerrar con <code>cap.release()</code> para liberar el dispositivo</li> </ul>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#ciclo-de-vida-camara","title":"Ciclo de vida c\u00e1mara","text":"<pre><code>\u2705 CORRECTO\ncap = cv2.VideoCapture(0)\nwhile True:\nret, frame = cap.read() # ret=True si lee bien\nif not ret: break\n\n...\ncap.release() # Libera c\u00e1mara para otras apps\ncv2.destroyAllWindows() # Cierra ventanas OpenCV\n\n\u274c ERROR: C\u00e1mara queda \"bloqueada\"\ncap = cv2.VideoCapture(0)\nwhile True:\nret, frame = cap.read()\n# Sin release() \u2192 otras apps no acceden c\u00e1mara\n</code></pre>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#2-comunicacion-serial-completa","title":"2. Comunicaci\u00f3n Serial Completa","text":""},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#inicializacion-robusta","title":"Inicializaci\u00f3n robusta","text":"<pre><code>PUERTO_SERIAL = 'COM11'\nBAUDRATE = 11520\nTIMEOUT = 0.01\n\ntry:\narduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\ntime.sleep(2) # Arduino necesita 2s para reset+boot\nprint(\"\u2713 Serial conectado\")\nexcept:\nprint(\"\u2717 Puerto no disponible\")\nexit()\n</code></pre> <p>time.sleep(2): Arduino hace reset al conectar USB, necesita tiempo para cargar sketch.</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#envio-de-comandos","title":"Env\u00edo de comandos","text":"<pre><code>comando = f\"X:{int(outputX)},Y:{int(outputY)},Z:{int(outputArea)}\\n\"\narduino.write(comando.encode()) # String \u2192 bytes\n</code></pre> <ul> <li><code>\\n</code> = terminador necesario para <code>readStringUntil('\\n')</code> en Arduino</li> <li><code>encode()</code> convierte string Python a bytes seriales</li> </ul>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#cierre-seguro","title":"Cierre seguro","text":"<pre><code>Antes de salir\narduino.write(b\"X:0,Y:0,Z:0\\n\") # Servos a posici\u00f3n segura\ntime.sleep(0.5) # Servo llega a posici\u00f3n\narduino.close() # Libera puerto serial\n</code></pre>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#3-clase-pid-explicacion-matematica","title":"3. Clase PID - Explicaci\u00f3n Matem\u00e1tica","text":"<pre><code>class PID:\ndef update(self, measurement):\nerror = self.setpoint - measurement # Error actual\n</code></pre> <pre><code>self.integral += error * self.dt     # \u2211error\u00b7\u0394t (acumula)\nself.integral = np.clip(self.integral, -50, 50)  # Anti-windup\n\nderivative = (error - self.prev_error) / self.dt  # \u0394error/\u0394t\nself.output = (self.Kp*error + \n              self.Ki*self.integral + \n              self.Kd*derivative)\nself.output = np.clip(self.output, -90, 90)  # L\u00edmite servo\n\nself.prev_error = error\nreturn self.output\n</code></pre> <p>np.clip(): Evita que servos vayan m\u00e1s all\u00e1 de l\u00edmites f\u00edsicos.</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#4-deteccion-hsv-por-que-dos-rangos-para-rojo","title":"4. Detecci\u00f3n HSV - \u00bfPor qu\u00e9 dos rangos para rojo?","text":"<pre><code>Rojo envuelve H=0\u00b0 y H=180\u00b0 (c\u00edrculo HSV)\nredbajo1 = np.array() # Rojo inicial (0-8)\u200b\nredalto1 = np.array()\nredbajo2 = np.array() # Rojo final (170-179)\u200b\nredalto2 = np.array()\nmask = cv2.add(mask1, mask2) # Combina ambos\n</code></pre> <p>S=150, V=50: Filtra rojos saturados y brillantes, elimina sombras/grises.</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#5-procesamiento-morfologico","title":"5. Procesamiento Morfol\u00f3gico","text":"<pre><code>kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\nmask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel) # Elimina ruido\nmask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel) # Une huecos\n</code></pre> <ul> <li>OPEN: Erosi\u00f3n \u2192 Dilataci\u00f3n = elimina puntos sueltos</li> <li>CLOSE: Dilataci\u00f3n \u2192 Erosi\u00f3n = une regiones separadas</li> <li>ELLIPSE: M\u00e1s suave que rect\u00e1ngulo</li> </ul>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#6-seleccion-mejor-contorno","title":"6. Selecci\u00f3n Mejor Contorno","text":"<pre><code>for c in contornos:\narea = cv2.contourArea(c)\nif 100 &lt; area &lt; 8000: # Filtra ruido/objetos grandes\nM = cv2.moments(c)\nif M[\"m00\"] != 0: # \u00c1rea v\u00e1lida\ncx = int(M[\"m10\"] / M[\"m00\"]) # Centro X\ncy = int(M[\"m01\"] / M[\"m00\"]) # Centro Y\nif area &gt; mejor_area: # Mayor = objetivo principal\nmejor_contorno = c\n</code></pre> <p>m00=0: Contorno con \u00e1rea cero (inv\u00e1lido).</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#7-filtro-exponencial-estabilidad","title":"7. Filtro Exponencial (Estabilidad)","text":"<pre><code>alpha = 0.6 # 60% nuevo, 40% anterior\nerrorX = alpha * errorX_raw + (1-alpha) * prev_errorX\n</code></pre> <p>Ejemplo: Error raw: 10\u219250\u2192-20 \u2192 Filtrado: 10\u219228\u219216 (suave).</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#8-bucle-principal-explicado","title":"8. Bucle Principal Explicado","text":"<pre><code>while True:\nret, frame = cap.read()\nif not ret: break # C\u00e1mara desconectada\n</code></pre> <p>frame = cv2.flip(frame, 1)  # Espejo (intuitivo) centrox = frame.shape // 2  # Centro ancho[2] centroy = frame.shape // 2  # Centro alto</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#deteccion-hsv-pid-serial-visualizar","title":"[Detecci\u00f3n HSV \u2192 PID \u2192 Serial \u2192 Visualizar]","text":"<p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):  # ESC o 'q'     break</p> <p>waitKey(1): 1ms delay, ~1000 FPS m\u00e1ximo (limitado por c\u00e1mara).</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#9-visualizacion-informativa","title":"9. Visualizaci\u00f3n Informativa","text":"<pre><code>cv2.circle(frame, (centrox, centroy), 8, (0,255,0), -1) # Centro VERDE\ncv2.circle(frame, (mejor_cx, mejor_cy), 7, (0,0,255), -1) # Target ROJO\ncv2.drawContours(frame, [hull], 0, (255,255,0), 2) # Contorno CYAN\ncv2.putText(frame, f'X11:{int(outputX)}', ...) # Valores PID\n</code></pre>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#10-limpieza-final-critica","title":"10. Limpieza Final (CR\u00cdTICA)","text":"<pre><code>1. Servos a posici\u00f3n segura\narduino.write(b\"X:0,Y:0,Z:0\\n\")\ntime.sleep(0.5) # Servo se mueve\n\n2. Liberar recursos\ncap.release() # C\u00e1mara libre para otras apps\narduino.close() # Puerto serial libre\ncv2.destroyAllWindows() # Cierra todas ventanas OpenCV\n</code></pre> <p>Sin release(): C\u00e1mara queda bloqueada, serial ocupado.</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#codigo-arduino-completo","title":"C\u00f3digo Arduino Completo","text":"<pre><code>#include &lt;Servo.h&gt;\nServo servoX(11), servoY(6), servoZ(5);\n\nvoid setup() {\nSerial.begin(11520);\nservoX.write(90); servoY.write(90); servoZ.write(90); // Neutral\n}\n\nvoid loop() {\nif (Serial.available()) {\nString cmd = Serial.readStringUntil('\\n');\n// Parsing robusto con \u00edndices\nint x = cmd.substring(cmd.indexOf(\"X:\")+2, cmd.indexOf(\",Y\")).toInt();\nservoX.write(map(x, -90,90,0,180));\n}\n}\n</code></pre> <p>int x = cmd.substring(idxX, cmd.indexOf(\",\", idxX)).toInt(); int y = cmd.substring(idxY, cmd.indexOf(\",\", idxY)).toInt(); int z = cmd.substring(idxZ).toInt();</p> <p>servoX.write(map(x, -90, 90, 0, 180)); servoY.write(map(y, -90, 90, 0, 180)); servoZ.write(map(z, -90, 90, 0, 180));</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#tabla-hsv-por-color-objetivo","title":"Tabla HSV por Color Objetivo","text":"Color H_bajo1 H_alto1 H_bajo2 H_alto2 S_min V_min Rojo 0 8 170 179 150 50 Verde 50 75 - - 100 50 Azul 100 130 - - 100 50 Amarillo 20 35 - - 150 100 Naranja 10 25 - - 150 100 P\u00farpura 140 160 - - 100 50 Rosa 160 175 - - 100 100 Cian 80 100 - - 100 100 <p>Uso: Reemplazar rangos rojo por el color deseado en el c\u00f3digo.</p>"},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#codigo-python-completo","title":"C\u00f3digo Python Completo","text":""},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#import-cv2-import-numpy-as-np-import-serial-import-serialtoolslist_ports-import-time-puerto_serial-com11-baudrate-11520-timeout-001-try-arduino-serialserialpuerto_serial-baudrate-timeouttimeout-timesleep2-print-serial-conectado-except-print-error-puerto-exit-class-pid-def-initself-kp-ki-kd-setpoint0-dt003-selfkp-kp-selfki-ki-selfkd-kd-selfsetpoint-setpoint-selfdt-dt-selfprev_error-0-selfintegral-0-selfoutput-0-def-updateself-measurement-error-selfsetpoint-measurement-selfintegral-error-selfdt-selfintegral-npclipselfintegral-50-50-derivative-error-selfprev_error-selfdt-selfoutput-selfkperror-selfkiselfintegral-selfkdderivative-selfoutput-npclipselfoutput-90-90-selfprev_error-error-return-selfoutput-pid_x-pid08-005-015-pid_y-pid08-005-015-pid_area-pid03-002-008-setpoint2000-cap-cv2videocapture0-alpha-06-prev_errorx-prev_errory-0-0-print-balanza-pid-3d-while-true-ret-frame-capread-if-not-ret-break-frame-cv2flipframe-1-centrox-frameshape-22-centroy-frameshape-2-hsv-cv2cvtcolorframe-cv2color_bgr2hsv-redbajo1-nparray-redalto1-nparray1-redbajo2-nparray-redalto2-nparray1-mask1-cv2inrangehsv-redbajo1-redalto1-mask2-cv2inrangehsv-redbajo2-redalto2-mask-cv2addmask1-mask2-kernel-cv2getstructuringelementcv2morph_ellipse-55-mask-cv2morphologyexmask-cv2morph_open-kernel-mask-cv2morphologyexmask-cv2morph_close-kernel-contornos-_-cv2findcontoursmask-cv2retr_external-cv2chain_approx_simple-mejor_contorno-none-mejor_cx-mejor_cy-mejor_area-none-none-0-for-c-in-contornos-area-cv2contourareac-if-100-area-8000-m-cv2momentsc-if-mm00-0-cx-intmm10-mm00-cy-intmm01-mm00-if-area-mejor_area-mejor_contorno-c-mejor_cx-mejor_cy-cx-cy-mejor_area-area-if-mejor_contorno-is-not-none-errorx_raw-mejor_cx-centrox-errory_raw-mejor_cy-centroy-errorx-alpha-errorx_raw-1-alpha-prev_errorx-errory-alpha-errory_raw-1-alpha-prev_errory-prev_errorx-prev_errory-errorx-errory-outputx-pid_xupdateerrorx-outputy-pid_yupdateerrory-outputarea-pid_areaupdatemejor_area-comando-fxintoutputxyintoutputyzintoutputarean-arduinowritecomandoencode-cv2circleframe-intmejor_cx-intmejor_cy-7-00255-1-hull-cv2convexhullmejor_contorno-cv2drawcontoursframe-hull-0-2552550-2-else-arduinowritebx0y0z0n-cv2circleframe-centrox-centroy-8-02550-1-cv2imshowbalanza-pid-3d-frame-if-cv2waitkey1-0xff-ordq-break-arduinowritebx0y0z0n-timesleep05-caprelease-arduinoclose-cv2destroyallwindows-print-sistema-cerrado","title":"<pre><code>import cv2\nimport numpy as np\nimport serial\nimport serial.tools.list_ports\nimport time\n\nPUERTO_SERIAL = 'COM11'\nBAUDRATE = 11520\nTIMEOUT = 0.01\n\ntry:\narduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\ntime.sleep(2)\nprint(\"\u2713 Serial conectado\")\nexcept:\nprint(\"\u2717 ERROR puerto\")\nexit()\n\nclass PID:\ndef init(self, Kp, Ki, Kd, setpoint=0, dt=0.03):\nself.Kp = Kp; self.Ki = Ki; self.Kd = Kd\nself.setpoint = setpoint; self.dt = dt\nself.prev_error = 0; self.integral = 0; self.output = 0\n\ndef update(self, measurement):\n    error = self.setpoint - measurement\n    self.integral += error * self.dt\n    self.integral = np.clip(self.integral, -50, 50)\n    derivative = (error - self.prev_error) / self.dt\n    self.output = self.Kp*error + self.Ki*self.integral + self.Kd*derivative\n    self.output = np.clip(self.output, -90, 90)\n    self.prev_error = error\n    return self.output\n\npid_x = PID(0.8, 0.05, 0.15)\npid_y = PID(0.8, 0.05, 0.15)\npid_area = PID(0.3, 0.02, 0.08, setpoint=2000)\n\ncap = cv2.VideoCapture(0)\nalpha = 0.6\nprev_errorX, prev_errorY = 0, 0\n\nprint(\"\ud83c\udfaf BALANZA PID 3D\")\nwhile True:\nret, frame = cap.read()\nif not ret: break\n\nframe = cv2.flip(frame, 1)\ncentrox = frame.shape // 2[2]\ncentroy = frame.shape // 2\n\nhsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\nredbajo1 = np.array(); redalto1 = np.array()[1]\nredbajo2 = np.array(); redalto2 = np.array()[1]\n\nmask1 = cv2.inRange(hsv, redbajo1, redalto1)\nmask2 = cv2.inRange(hsv, redbajo2, redalto2)\nmask = cv2.add(mask1, mask2)\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\nmask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)\nmask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)\n\ncontornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\nmejor_contorno = None; mejor_cx, mejor_cy, mejor_area = None, None, 0\n\nfor c in contornos:\n    area = cv2.contourArea(c)\n    if 100 &lt; area &lt; 8000:\n        M = cv2.moments(c)\n        if M[\"m00\"] != 0:\n            cx = int(M[\"m10\"] / M[\"m00\"])\n            cy = int(M[\"m01\"] / M[\"m00\"])\n            if area &gt; mejor_area:\n                mejor_contorno = c\n                mejor_cx, mejor_cy = cx, cy\n                mejor_area = area\n\nif mejor_contorno is not None:\n    errorX_raw = mejor_cx - centrox\n    errorY_raw = mejor_cy - centroy\n    errorX = alpha * errorX_raw + (1-alpha) * prev_errorX\n    errorY = alpha * errorY_raw + (1-alpha) * prev_errorY\n    prev_errorX, prev_errorY = errorX, errorY\n\n    outputX = pid_x.update(errorX)\n    outputY = pid_y.update(errorY)\n    outputArea = pid_area.update(mejor_area)\n\n    comando = f\"X:{int(outputX)},Y:{int(outputY)},Z:{int(outputArea)}\\n\"\n    arduino.write(comando.encode())\n\n    cv2.circle(frame, (int(mejor_cx), int(mejor_cy)), 7, (0,0,255), -1)\n    hull = cv2.convexHull(mejor_contorno)\n    cv2.drawContours(frame, [hull], 0, (255,255,0), 2)\nelse:\n    arduino.write(b\"X:0,Y:0,Z:0\\n\")\n\ncv2.circle(frame, (centrox, centroy), 8, (0,255,0), -1)\ncv2.imshow('BALANZA PID 3D', frame)\n\nif cv2.waitKey(1) &amp; 0xFF == ord('q'): break\n\narduino.write(b\"X:0,Y:0,Z:0\\n\")\ntime.sleep(0.5)\ncap.release()\narduino.close()\ncv2.destroyAllWindows()\nprint(\"\u2713 Sistema cerrado\")\n</code></pre>","text":""},{"location":"Proyecto%20plataforma%20stewart/Open%20cv/#evidencias","title":"Evidencias","text":""}]}